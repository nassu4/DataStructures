 - ## 优先队列
   * ### 基本知识
     + **优先队列** 是一种数据结构，它支持两种操作：*删除最大元素* 和 *插入元素*

       > 许多应用程序都需要处理有序的元素，但不一定要求它们全部有序，或是不一定要一次就将它们排序。很多情况下我们会收集一些元素，处理当前键值最大的元素，然后再收集更多的元素，再处理当前键值最大的元素( *例如为每个应用程序分配一个优先级，并总是处理下一个优先级最高的应用程序* )。这时候我们就可以用到优先队列。

   * ### API
     + 泛型优先队列的API
           public class MaxPQ<Key extends Comparable<key>>
           -----------------------------------------------
                        MaxPQ()                     创建一个优先队列
                        MaxPQ(int max)              创建一个初始容量为max的优先队列
                        MaxPQ(Key[] a)              用a[]中的元素创建一个优先队列
                  void  insert(Key v)               向优先队列中插入一个元素
                  Key   max()                       返回最大元素
                  Key   delMax()                    删除并返回最大元素
               boolean  isEmpty()                   返回队列是否为空
                  int   size()                      返回优先队列中元素的个数

   * ### 初级实现( *代码见排序文件夹内内容* )
     + 数组实现(无序)

     + 数组实现(有序)

     + 链表表示法

   * ### 堆的定义
     + 当一颗二叉树的每个结点都大于等于它的两个子节点时，它被称为堆有序。

     + 根节点是堆有序的二叉树中的最大节点

     + 二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存(不使用数组的第一个位置)

     + 一颗大小为N的完全二叉树的高度为lgN(向下取整)

   * ### 堆的算法
     + *堆的有序化* 堆的操作会首先进行一些简单的改动，打破堆的状态，然后再遍历堆并按照要求将堆的状态恢复。

       > 在有序化的过程中我们会遇到两种情况。
       > 1. 当某个结点的优先级上升(或是在堆底加入一个新的元素)时，我们需要 *由下至上* 恢复堆的顺序。

       > 2. 当某个结点的优先级下降(例如，将根节点替换为一个较小元素时)，我们需要 *由上至下* 恢复堆的顺序。

     + 由下至上的堆有序化(上浮)

       > 如果堆的有序状态被某个结点比它的父结点更大而被打破，那么我们就需要交换它和它的父节点来修复堆。

       > 交换后，这个结点比它的两个子结点都大，但这个结点仍然可能比他的父结点更大，我们可以用相同的方法交换它和它的父节点，直到遇到了一个更大的父节点。

           private void swim(int k)
           {
             while( k > 1 && less(k/2,k) )
             {
               exch(k/2,k);
               k = k/2;
             }
           }

     + 由上至下的堆有序化(下沉)

       > 如果堆的有序状态被某个结点变得比它的两个子结点或是其中之一更小而被打破了，那么我们可以通过将它和它的两个子结点中较大者交换来恢复堆。

       > 交换可能会在子结点处继续打破堆的有序状态，因此我们需要不断地用相同的方式将它修复，直到它的子结点都比它小为止。

           private void sink(int k)
           {
             while(2*k <= N)
             {
               int j = 2*k;
               if( j < N && less(j,j+1) ) j++;
               if( !less( k, j ) ) break;
               exch( k , j );
               k = j;
             }
           }

     + 对于一个含有N个元素的基于堆的优先队列，插入元素操作只需不超过(lgN+1)次比较，删除最大元素的操作只需不超过2lgN次比较。

   * ### 堆排序
     + **堆排序分为两个阶段**
       1. *堆的构造* 阶段，我们将原始数组重新组织安排进一个堆中。

       2. *下沉排序* 阶段，我们从堆中按递减的顺序取出所有元素并得到排序结果。

     + **堆的构造**
       - 聪明高效的方法是从右至左用sink()函数构造子堆。数组的每个位置都已经是一个子堆的根节点了，sink()函数对于这些子堆也适用。

       - 如果一个结点的两个子结点都已经是堆了，那么在该结点上调用sink()就可以把他们变成一个堆。

       - 开始时，只需要扫描数组中一般的元素，因为我们可以跳过大小为1的子堆。

       - 用下沉操作由N个元素构造堆只需少于2N次比较以及少于N次交换。

     + **代码示例**

           public static void sort(Comparable[] a)
           {
               int N = a.length;
               for( int k = N/2; k >= 1; k-- ){
                   sink( a, k, N );
               }
               while( N > 1 ){
                   exch( a, 1, N-- );
                   sink( a, 1, N );
               }
           }

     + **算法特性**
       - 将N个元素排序，堆排序只需少于(2NlgN+2N)次比较(以及一般次数的交换)

       - 堆排序能够同时最优地利用空间和时间——在最坏的情况下它也能保证使用~2NlgN次比较和恒定的额外空间。

       - 缺点为：无法利用缓存，因为数组元素很少和相邻的其他元素进行比较，因此缓存未命中的次数要远远高于大多数比较都在相邻元素间进行的算法。
